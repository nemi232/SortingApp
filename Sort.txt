using System;
using System.Collections.Generic;
using System.IO;

namespace SortingFileContents
{
    // Interfejs strategii sortowania
    public interface ISortStrategy<T> where T : IComparable<T>
    {
        IEnumerable<T> Sort(IEnumerable<T> data);
    }

    // Implementacja sortowania bąbelkowego
    public class BubbleSortStrategy<T> : ISortStrategy<T> where T : IComparable<T>
    {
        public IEnumerable<T> Sort(IEnumerable<T> data)
        {
            var array = new List<T>(data);
            int n = array.Count;
            bool swapped;
            
            do
            {
                swapped = false;
                for (int i = 1; i < n; i++)
                {
                    if (array[i - 1].CompareTo(array[i]) > 0)
                    {
                        T temp = array[i - 1];
                        array[i - 1] = array[i];
                        array[i] = temp;
                        swapped = true;
                    }
                }
                n--;
            } while (swapped);

            return array;
        }
    }

    // Implementacja sortowania quicksort
    public class QuickSortStrategy<T> : ISortStrategy<T> where T : IComparable<T>
    {
        public IEnumerable<T> Sort(IEnumerable<T> data)
        {
            var array = new List<T>(data);
            QuickSort(array, 0, array.Count - 1);
            return array;
        }

        private void QuickSort(List<T> array, int left, int right)
        {
            if (left < right)
            {
                int partitionIndex = Partition(array, left, right);

                QuickSort(array, left, partitionIndex - 1);
                QuickSort(array, partitionIndex + 1, right);
            }
        }

        private int Partition(List<T> array, int left, int right)
        {
            T pivot = array[right];
            int i = left - 1;

            for (int j = left; j < right; j++)
            {
                if (array[j].CompareTo(pivot) <= 0)
                {
                    i++;
                    T temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
            }

            T temp1 = array[i + 1];
            array[i + 1] = array[right];
            array[right] = temp1;

            return i + 1;
        }
    }

    // Implementacja sortowania merge sort
    public class MergeSortStrategy<T> : ISortStrategy<T> where T : IComparable<T>
    {
        public IEnumerable<T> Sort(IEnumerable<T> data)
        {
            var array = new List<T>(data);
            MergeSort(array, 0, array.Count - 1);
            return array;
        }

        private void MergeSort(List<T> array, int left, int right)
        {
            if (left < right)
            {
                int middle = (left + right) / 2;

                MergeSort(array, left, middle);
                MergeSort(array, middle + 1, right);

                Merge(array, left, middle, right);
            }
        }

        private void Merge(List<T> array, int left, int middle, int right)
        {
            int n1 = middle - left + 1;
            int n2 = right - middle;

            T[] leftArray = new T[n1];
            T[] rightArray = new T[n2];

            Array.Copy(array.ToArray(), left, leftArray, 0, n1);
            Array.Copy(array.ToArray(), middle + 1, rightArray, 0, n2);

            int i = 0, j = 0;
            int k = left;

            while (i < n1 && j < n2)
            {
                if (leftArray[i].CompareTo(rightArray[j]) <= 0)
                {
                    array[k] = leftArray[i];
                    i++;
                }
                else
                {
                    array[k] = rightArray[j];
                    j++;
                }
                k++;
            }

            while (i < n1)
            {
                array[k] = leftArray[i];
                i++;
                k++;
            }

            while (j < n2)
            {
                array[k] = rightArray[j];
                j++;
                k++;
            }
        }
    }

    // Kontekst sortowania
    public class SortContext<T> where T : IComparable<T>
    {
        private ISortStrategy<T> _strategy;

        public SortContext(ISortStrategy<T> strategy)
        {
            _strategy = strategy;
        }

        public IEnumerable<T> ExecuteStrategy(IEnumerable<T> data)
        {
            return _strategy.Sort(data);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Welcome to File Sorting Program!");

            // Pobieranie ścieżki pliku od użytkownika
            Console.Write("Enter the path to the file to sort: ");
            string filePath = Console.ReadLine();

            // Wybór algorytmu sortowania
            Console.WriteLine("Choose sorting algorithm:");
            Console.WriteLine("1. Bubblesort");
            Console.WriteLine("2. Quicksort");
            Console.WriteLine("3. Merge sort");
            Console.Write("Enter your choice (1-3): ");

            int choice;
            while (!int.TryParse(Console.ReadLine(), out choice) || choice < 1 || choice > 3)
            {
                Console.Write("Invalid input. Enter your choice (1-3): ");
            }

            ISortStrategy<string> sortStrategy = null;

            // Wybór strategii sortowania na podstawie wyboru użytkownika
            switch (choice)
            {
                case 1:
                    sortStrategy = new BubbleSortStrategy<string>();
                    break;
                case 2:
                    sortStrategy = new QuickSortStrategy<string>();
                    break;
                case 3:
                    sortStrategy = new MergeSortStrategy<string>();
                    break;
                default:
                    break;
            }

            // Kontekst sortowania
            var sortContext = new SortContext<string>(sortStrategy);

            // Odczyt pliku i sortowanie linii
            try
            {
                List<string> lines = new List<string>(File.ReadAllLines(filePath));
                var sortedLines = sortContext.ExecuteStrategy(lines);

                Console.WriteLine("Sorted content:");
                foreach (var line in sortedLines)
                {
                    Console.WriteLine(line);
                }
            }
            catch (FileNotFoundException)
            {
                Console.WriteLine($"File '{filePath}' not found.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
            }

            Console.WriteLine("Press any key to exit...");
            Console.ReadKey();
        }
    }
}
